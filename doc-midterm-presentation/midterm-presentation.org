#+STARTUP: beamer
#+TITLE: A Haskell Platform for Creating Progressive Web Applications
#+SUBTITLE: A midterm progress report
#+DATE: 2019-01-29
#+AUTHOR: Jakub Zárybnický
#+OPTIONS: H:2 toc:t num:t
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Madrid
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col) %8BEAMER_OPT(Opt)

* What, why?
** Motivation
- The trend of FP on the frontend, motivated by Elm, PureScript (langs inspired
  by Haskell, but also limited).
- The full power of Haskell, sharing common code with the server
- Rapidly growing area in the Haskell ecosystem, many companies involved:
  - Obsidian -
  - Tweag -
  - QFPL -
  - IOHK -
- Growing, but still not established - missing tools and libraries
- More immediate need - I have clients with projects that are waiting on this
  thesis' results

** Assignment
Create "A Haskell Platform for Creating Progressive Web Applications"

What's a PWA?
- "Progressive Web Application"
- new buzzword from Google
- an /almost/ native app
  - load a website
  - save to phone homepage like an app
  - available offline, perhaps with data sync
  - use push notifications, device APIs

Why this particular topic?
- many missing tools in the ecosystem
- I chose PWA - personal need, started a new project in August and September
  without necessary tools
- The projects is mostly done, but it still isn't a PWA

** Goal drift
Since the start of the project, my goals have drifted a bit:
- PWA framework and a set of tools
- full-stack framework, Meteor-alike
- all the web-dev tools missing from Haskell
- application patterns - static site, JAM (recompile-on-demand), real-time app, ...

* What's done?
** What have I been doing?
How am I working?
- in part extracting relevant parts from my existing Haskell applications
- in part research, type and API design

So far:
- survey of web frameworks all around the programming world
- survey of the Haskell ecosystem around web-development
- attempts at a blog where I post regular updates around this work - a failure
  so far, I got stuck on the second post for >2 months...
- type design for the core of the application (= business logic, a la "functional core, imperative shell")
- proof-of-concept of a full-stack application
- proof-of-concept of a JAM-stack-alike
- proof-of-concept of an offline-capable client application
- proof-of-concept of a frontend debugger toolbar (very limited so far)
- attempts at type design for the sync and transport part - I found a lot of
  ways that don't work or read/write well

- a mile long to-do list full of must-haves and nice-to-haves

-- add screenshots
-- what's publicly available? (repo, zarybnicky.com repo)

** Technologies
Haskell, Nix, (JS, CSS)

Haskell - why, what is it, why is it interesting?
- since 1990, actively developed, rooted in academia and still the target of
  active research - "Dependent Haskell", "Linear Haskell"
- purely functional programming language with type inference and lazy evaluation
- expressive types, dialog with the compiler, types encoding effects
- language to write reliable software in - it eliminates entire classes of
  programming errors - usually the ones that remain are logic errors
- example of a nicely expressive type - servant

#+BEGIN_SRC haskell
type HackageAPI =
       "users" :> Get '[JSON] [UserSummary]
  :<|> "user" :> Capture "username" Username :> Get '[JSON] UserDetailed
  :<|> "packages" :> Get '[JSON] [Package]

getUsers :: Handler [UserSummary]
getUser :: Username -> Handler UserDetailed
getPackages :: Handler [Package]

# server-side
server :: Server HackageApi
server = getUsers :<|> getUser :<|> getPackages

# client-side
getUsers :<|> getUser :<|> getPackages =
  client @HackageApi "http://hackage.haskell.org"
#+END_SRC

Nix - why, what is it, why is it interesting?
- since 2004, Eelco Dolstra's Ph.D. thesis in 2006
- purely functional, lazy evaluation
- one program consists of a closure that includes all dependencies including libc
- atomic upgrades, rollbacks
- complete isolation of dependencies, no DLL hell
- NixOS - OS built on top of Nix, NixOps - a cloud deployment tool, combines
  Terraform/CloudFormation and Puppet/Ansible with Nix (specify desired state,
  Nix does the magic to make it happen. AWS, VPSs, VirtualBox, ...).

* What's next?
** Plans
Three tiers of plans:
- PWA = basic, as per assignment
- data sync = extra goal, would be quite an achievement
- vision for the future = pattern language, ...

-- add images (see board)

** Next tasks
Wrapping up pas work:
- finish article drafts
- finish extracting useful patterns from my applications

Opening new areas:
- ServiceWorker wrapper or template
- push notifications (should be trivial)
- pre-rendering (build- or runtime)
- CLI tool
- type design for data channel/synchronization

* Conclusion
** What's left?
- build on the introduction

** Schedule
