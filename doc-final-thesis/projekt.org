* (front matter)                                              :ignoreheading:
#+OPTIONS: texht:nil toc:nil author:nil
#+LATEX_CLASS: fitthesis
#+LATEX_CLASS_OPTIONS: [english,odsaz]
#+BIND: org-latex-title-command ""
# zadani = includes zadani.pdf
# print = B&W links and logo
# cprint = B&W links, color logo
# %\graphicspath{{obrazky-figures/}{./obrazky-figures/}}
#+LaTeX_HEADER: \input{metadata}
#+LATEX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usepackage[figure,table]{totalcount}
#+BEGIN_EXPORT latex
\maketitle
\setlength{\parskip}{0pt}
{\hypersetup{hidelinks}\tableofcontents}
\iftotalfigures\listoffigures\fi
\iftotaltables\listoftables\fi
\iftwoside\cleardoublepage\fi
\setlength{\parskip}{0.5\bigskipamount}
#+END_EXPORT

* Introduction
Let's imagine we want to create a new e-shop, with all the conveniences that
customers are nowadays used to - [TODO: ...], a notification when the order is
ready, and ideally an offline-available overview of the order for when the user
is picking it up. What would be the easiest way to implement such a service? If
we want to show something offline, we need a mobile application, the same for
notifications. But [TODO: research about mobile engagement] and downloading a
mobile application means another dozen megabytes.

That's what the new trend of Progressive Web Applications (PWAs) is trying to
solve. Fast - no need to wait for page reloads, Reliable - service workers help
overcome problems with unreliable internet - both for page load (by caching the
app itself, and in-app caching of app-specific data) and for background sync of
user-modified data.

But my language of choice is Haskell, for both frontend and backend development,
and while writing Haskell applications for the browser is possible, creating a
Progressive Web Application requires more than just the ability to manipulate
the DOM. That is what this work is about - filling in the gaps and creating all
the prerequisites for writing Progressive Web Applications in Haskell. We will
start by identifying what is exactly is lacking in the Haskell ecosystem and
design and implement those missing pieces. Afterwards, we'll walk through the
process of creating a PWA from prototype to production and see what else could
be made easier and more straightforward as a follow-up to this work.

** Related work
While using Haskell in the browser is not a common choice, it is still a quickly
growing niche. it is a relatively recent one as GHCJS, the Haskell-to-JavaScript
compiler, has been in development since 2010 [TODO: gh repo link] but it had a
production-ready version only in 2013 [luite's blog]. It is not the target of
academic work, but there are several commercially sponsored projects. To name a
few, Reflex and Obelisk from Obsidian Systems [TODO: link], Asterius from Tweag,
and many learning materials from QFPL [TODO: their github].

While it's a quickly growing area, it's still not an established one, and there
are many libraries and tools still missing, ones that developers used to other
languages have learned to expect and require.

* Technologies
We'll first have a more detailed look at the above-mentioned technologies, at
what the term Progressive Web Application means and why would one want to use
Haskell when creating browser applications.

** Progressive Web Application
"Progressive Web Application" is a term that covers several relatively new
technologies. It is the continuation of the general trend of expanding the
capabilities of browser applications and closing the gap between them and native
mobile applications. While many of these technologies apply also on desktop, the
main target audience is mobile - [TODO: some statistics].

The technologies are:
- Web App Manifest - a specification for the centralized location of application
  metadata - its name, icons, display mode, ...
- Service Workers - "a scriptable network proxy" [TODO: as per Wiki]. The
  technology that takes care of offline-availability, push notifications, and
  background synchronization.
- IndexedDB - a storage location that is accessible from the browser as well as
  the service worker, it allows background sync to work with the application
  state directly
- Web Platform APIs - a set of APIs that expose capabilities of the underlying
  system [TODO: https://whatwebcando.today/] - examples include geolocation or
  audio/video capture

What is a Progressive Web Applications exactly is defined by a checklist created
by Google, the https://developers.google.com/web/progressive-web-apps/checklist
[TODO: ref]. It describes two levels of PWAs, a 'Baseline PWA' and an 'Exemplary
PWA'. The main defining characteristics of a Baseline PWA are: served over
HTTPS, responsive design, all URLs available even while offline, and
non-blocking page transitions. While there are more requirements for an
Exemplary PWA, these are the most important ones.

Some more notable PWAs are: Instagram, Twitter [TODO: refs, see wiki], Uber,
Flipkart, or Tinder.

** Haskell
The programming language Haskell is a rather old one, despite spreading into the
industry only recently, having been around since 1990 [TODO: reference]. It is a
language that started out as a basis for research into the design of functional
languages. It has served as such, and in fact it still is the target of active
research - some more prominent projects are "Dependent Haskell" [TODO: ref] and
"Linear Haskell" [TODO: ref].

Haskell is described as a "statically typed, purely functional programming
language with type inference and lazy evaluation" [TODO: ref]. It is a language
in which its expressive type system enables very precise control over TODO:
expressive types, dialog with the compiler, types encoding effects, citation for
"If it compiles, it works".

Why Haskell? Strongly typed language, helps ensure correctness and prevent
undefined behaviors - but less verbose and more expressive than Java and other
languages a developer would imagine as 'strongly typed'. Haskell is one of the
many languages that can be used in the browser - not directly, but by compiling
down to JavaScript. WebAssembly is a technology that encourages this way
of working, enabling any language to run in the browser via LLVM. (Compiling
Haskell to WebAssembly is almost doable [TODO: ref WebGHC, Asterius].)

Compile-to-JavaScript languages aren't as rare as it may seem. While languages
that aren't based on JavaScript itself aren't exactly common, web developers
have been using JavaScript compilers for a long time - CoffeeScript is rather
popular language announced in 2010 [TODO: ref], and developers wanting to use
new ECMAScript 6 or 7 features (now supported in most browsers) also had no
choice but to use compilers [TODO: ref Babel history].

It is a language that enables its users to write reliable software - it
eliminates entire classes of programming errors [TODO: ref, enumerate]. The
errors that remain even after the program successfully compiles are usually
logic or conceptual errors.

While Haskell is not a language commonly associated with frontend development,
it is one of the many languages with the ability to use JavaScript as the
compilation target, instead of plain assembly or LLVM. In fact, such languages
have now become quite common in frontend development [TODO: ref], as is
exemplified by the rapid rise of TypeScript, a superset of ECMAScript 6 [TODO:
ref], or Elm, a framework with its own language based on Haskell [TODO: ref].

Of the many reasons for selecting a language other than JavaScript for frontend
development, one of the more notable ones is the ability to share code between
the server and its client in the case they are written in the same
language. This is the basic idea of the framework Meteor [TODO: ref], and in
fact the ability to run 'isomorphic code' - the same code on the client and the
server both - is its main marketing point.

#+BEGIN_SRC haskell :exports code
  type HackageAPI =
    "users" :> Get '[JSON] [User] :<|>
    "user" :> Capture "login" Login :> Get '[JSON] User :<|>
    "packages" :> Get '[JSON] [Package]

  getUsers :: Handler [User]
  getUser :: Login -> Handler User
  getPackages :: Handler [Package]

  server :: Server HackageApi
  server = getUsers :<|> getUser :<|> getPackages

  getUsers :<|> getUser :<|> getPackages =
    client @HackageApi "http://hackage.haskell.org"
#+END_SRC

** Nix
One technology that wasn't yet mentioned but that will support our entire build
process - from compiling to deploying - is Nix. Nix is a package manager with
focus on reproducibility and isolation. It is described as a purely functional
package manager, where every package is build by a function that doesn't have
side-effects and is immutable after being built, where Nix ensures that the
exact version of dependencies is used even during runtime - up to ~libc~ [TODO:
ref homepage]

Nix is a declarative build tool, similar in purpose to Make and in philosophy to
Haskell. There are other tools built on top of Nix though, the most interesting
being NixOS, a declarative operating system, and NixOps, a cloud deployment tool
[TODO: refs]. Nix shines at cross-compilation, which is the main I'll use it in
this thesis - compiling to JavaScript or Android/iOS is trivial after the
initial setup.

Nix is another rather old technology actively developed since 2004 after Eelco
Dolstra developed this idea in his academic work [TODO: refs]. One package
consists of a closure of all of its runtime dependencies, so even packages using
different versions of dynamically linked libraries or even libc can coexist on
the same machine. Adding atomic deployments and rollbacks is then quite easy, as
a user environment only consists of symbolic links to the read-only Nix store -
that is very useful for NixOS or NixOps.

[TODO: add an example Nix derivation]

[TODO: talk about why NixOps is my deployment tool of choice]

#+BEGIN_SRC nix :exports code
  {
    network.description = "Web server";

    webserver = { config, pkgs, ... }: {
      services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot =
        "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];

      deployment.targetEnv = "virtualbox";
    };
  }
#+END_SRC

* Research
In order to write a SPA/PWA, there are some tools and supporting libraries that
a developer can't live without. We'll first walk through a high-level overview
of the common features of the Web frameworks of today, then go through the most
popular frameworks and see where they shine. Afterwards, we'll have a look at
the ecosystem of Haskell and try to find its strong and weak points, and
especially the places where the tools or libraries are entirely missing.

** Common features of Web frameworks
-- A description of the things I'll be looking for, partially from
Wikipedia's [[https://en.wikipedia.org/wiki/Comparison_of_web_frameworks][Comparison of web frameworks]] and [[https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks][Comparison of JavaScript
frameworks]], partially from my own experience, and partially from the feature
lists of the frameworks that I'll be looking into.

*** Tooling
I'll start with the things you encounter first when setting up a project, its
tools. Developers have wildly differing levels of expectations from their tools. A
Python developer might expect just a text editor and an interpreter, whereas a
JVM developer might not be satisfied with anything less than a full-featured IDE.

*Code generators* or scaffolding tools start with creating a package manifest and
a ~src/~ directory, going on to generators that set up a few different types of
projects based on templates, all the way to tools that can add an entire website
module, perhaps even with database migrations.

*Build tools* range from a set of conventions on how to use your build tool that
might get formalized in your Makefile, through a CLI tool that takes care of
building, testing and perhaps even deploying your project, to the way of the IDE
where anything you can think of is just a few clicks away.

*Debugging tools* also come in many flavors and for many purposes. On the side of
the server, you have all the usual tools for the language, plus a few more - a
toolbar with an overview of everything that goes on in a page render or an AJAX
call, or the option to remotely connect to a running process and to debug
live. Client-side, we have the now irreplaceable DevTools with a built-in
debugger and profiler, but some frameworks go even further and provide a
framework-specific tools - React's component tree, or Elm's time-traveling
debugger.

*Quality assurance tools* have many sub-categories. From static code analysis
tools or linters, as they are commonly known; through tests - unit, integration,
end-to-end tests, or more exotic ones like marble tests or visual regression
tests; to profilers - runtime or allocation measurements, frontend performance
measurements, or more involved tools like performance evolution tracking.

*** Features
TODO: Reread and clean up

*Templating*, which at the frontend means a way to compose the HTML that makes up
an application, usually including some render logic and variable
interpolation. In some frameworks the whole program is a template (see React),
some have templates in separate files and pre-compile them during runtime (see
Angular). Templates sometimes contain CSS as well (see the new CSS-in-JS trend)

*Forms* are the basic element of interactive applications. There are a few layers
of abstraction at which a framework can decide to implement forms - starting at
raw DOM manipulation, going on to data containers with validation (but manual
rendering), all the way up to form builders, manual or automatic. Under 'forms'
I count a way to render a form, to validate user input, and collect the result.

*Routing* means manipulating the displayed URL using the History API and changing
the application state to reflect it, and also loading the correct state on
application start-up. This can also include animated transitions between pages.

*Internationalization* has many levels. At its most basic, it means simple string
translations, pluralization, and word order. Going further, it means also RTL
scripts, date/time formats, currency, or time zones.

Modern web frameworks also provide a way to use a web application's code and
compile it into a *native mobile application*. It's commonly implemented as a
wrapper application around web apps using Cordova, but technologies like React
Native go further and use native UI elements. Mobile applications can be faster
to use and faster to load, can access device-specific APIs not exposed via Web
Platform APIs.

Some frameworks also support creating a *desktop application* that reuses a web
application's code. The underlying technology here is Electron and not Cordova,
but the benefits are the same - greater speed and access to device-specific
functionality.

In the fields of web design and user experience, there is currently a large
focus on *accessibility*. Not only is it one of widely recognized web trends for
2018 [TODO: ref some trend lists, Delotte?], but it can be legally required in
some cases [TODO: ref ADA]. Accessibility on the web includes a range of
features, from semantic elements and text contrast (for screen-readers and users
with low vision), to keyboard accessibility and transcripts of audio/video
content. Support in frameworks ranges from ARIA attributes and key managers to
integrated accessibility testing (e.g. via aXe).

A part of real-time applications are *optimistic updates*, which broadly means
expecting that every network request will be successful and updating the GUI
accordingly, and rolling back the application state in the case of failure. It
is one of the topics I would like focus on, as it is a basic technique of good
UX (user experience), but I haven't found any good abstraction over it - likely
because it is a mixed responsibility of the UI, network and storage layers.

Support for the *Web Platform* is relevant for frameworks with non-trivial
application architecture, those that need to wrap external calls before they are
usable. Examples here include React's Hooks or Cycle.js's drivers. [TODO: refs].

One common technique for optimizing page speed - and also a requirement of a
PWA - is rendering the application's HTML on the server. Whether that means
rendering and sending just an application shell that will be filled when the
application itself loads or the rendered HTML of the entire application that the
application will take over depends on the level of the optimization, but the
intent here is to increase the perceived speed, as modern applications can get
quite big. This prerendering can take part during the build-time, or during
run-time - run-time rendering is called 'Server-side Rendering' and build-time
is either a [TODO: look up the terms].

TODO: What about the backend feature write-ups I have?

** JavaScript ecosystem
*** UI toolkit
The most popular JavaScript toolkits currently are Angular and React. Vue.js is
another one, relatively new but quickly growing. Of these, Angular is the
framework closest to traditional frameworks where to create an application, the
framework is all you need. Vue.js is a bit further

TODO: shorten snippet about Angular
On a first look, Angular looks like a well thought-out frontend
framework. Written in Typescript with comprehensive documentation and great
tooling, it seems that the authors have learned from their mistakes with
AngularJS.

Some negatives that developers complain about: Angular is intimidating for a new
developer, it's too complex and there's a lot to learn. Too much 'magic' -
related to the previous point, there's a lot of abstraction and it's not easy to
understand all the layers. Code bloat - the amount of boilerplate and also the
size of the resulting bundle. Too opinionated - if you don't like 'the angular
way', you're out of luck here. Scattered documentation - too many articles and
tutorials out there for AngularJS that can't work with the new Angular

TODO: shorten snippet about React
React is not a framework in itself. Rather, it's a library that focuses on a
single thing and does it in a unique enough way that there's sprung up an entire
ecosystem around it. In it, there are groups of libraries that build upon React,
each focusing on a single feature - UI components, state management, forms etc.

There's a large jungle of libraries, each one with a different scope and
focus. Choosing a library that fits your problem can sometimes take many
attempts. Add to it the fact that libraries, frameworks and tools come and go
quite quickly - the main cause of the so-called "JavaScript fatigue - and the
fact that in JavaScript, it's fashionable to write extremely small libraries,
and you have a recipe for a quite unpleasant development experience.

I'll try to go through some of the most popular 'frameworks' that build on
React, though each one is more of a pre-built toolkit of libraries and tools
and bits of glue in between, rather than cohesive frameworks. In general, the
React world is a lot more mix-and-match than developers used to enterprise
frameworks would expect.

TODO: shorten snippet about gatsby
One rather unique framework I found - and this is a framework in a strong
sense, not like the React tools above - is Gatsby. It's unique in the sense that
while it's a frontend framework, it's not supposed to run in a browser. It's a
part of a growing movement centered around the 'JAM stack' - "JavaScript, APIs,
and Markup". That doesn't tell you much, but the main feature is that at
build-time, you fetch data from your APIs, and render the application to plain
HTML files, so that you don't need a server other than an S3 bucket or similar.

It's a framework targeted at a specific subset of website - not single-page
applications, but more blogs or e-shops, and a workflow exemplified by Netlify.
This means it doesn't need to concern itself with many features that would be
missing in a frontend framework intended for a browser, and those are delegated
to a different part of the stack.

TODO: Vue.js
TODO: Polymer

*** Build tools
TODO: Webpack
TODO: Babel, ...

TODO: react's tools
Create-react-app, nwb, Razzle, and Neutrino all cover only the build
process. Next.js is the first one that I've found that goes a step beyond just
pre-configuring Webpack and other build tools - it provides other features that
are starting become standard - server-side runtime rendering, link prefetching,
and build-time prerendering. It's also the first tool I found that considers
that a website can consist of multiple applications, via its 'zones' feature.

*** UI components
TODO: mention the large libraries

*** Forms
TODO: mention angular's integration
TODO: mention React's breadth of tools

*** Routing
TODO: built-ins in angular, several libraries and approaches for react, not a
concern for gatsby

*** Mobile/desktop apps
- runtime environments - from server-side rendering, PWAs with ServiceWorkers,
  to native and desktop applications, it seems that Angular tries to cover every
  possible use-case
React - not explicit support, but Electron etc.

*** Accessibility
TODO: Explicit instructions and support in both React and Angular

*** Optimistic updates
TODO: angular
TODO: react

*** Web Platform
native support, no need for special support
but - TODO: react/angular wrappers for streams or contexts, ...

*** Prerender
TODO: react-server
TODO: angular also builtin? TODO: check

*** Support tools
Angular
- command line tool, ~ng~ - it streamlines setting up the entire project -
  scaffolding, preparing build and testing tools, starting a
  development server, ...
- tooling other than the ~ng~ tool - browser extensions for runtime debugging,
  IDEs and others. I haven't thought of a tool I would miss, but I'm used to
  minimalism in tooling from the Haskell world...

React - depends in the distribution

** PHP ecosystem
TODO: PHP ecosystem

** Haskell ecosystem
*** UI toolkit
At the frontend, it is the UI toolkit that defines what the entire application
will look like, its architecture as well as the tools it can use. There is
significant focus on the semantics of libraries in the Haskell community, with
well-defined and law-abiding foundation types, so UI libraries have mostly used
Functional Reactive Programming (FRP) or its derivatives like 'the Elm
architecture' [TODO: ref] as their basis.

There are five production-ready browser UI toolkits that I have found. Out of
these five, ~react-flux~ and ~transient~ are unmaintained. ~Reflex~, ~miso~, and ~concur~
are actively developed and ready for production use. Each one is a conceptually
different approach to the problem of browser user interfaces, but they differ in
their maturity and the size of their community as well.

~Reflex~ [TODO: ref] and ~reflex-dom~ [TODO: ref], its DOM bindings, seem like the
most actively maintained ones. ~Reflex~ is also sponsored by Obsidian Systems
[TODO: ref] and the most popular one in the Haskell community, so its future
seems promising. ~Reflex~ follows the traditional FRP with events and behaviors,
adding 'dynamics' to the mix, and building a rich combinator library on top of them.

~Miso~ [TODO: ref] - TODO: Elm architecture re-implementation in Haskell

~Concur~ [TODO: ref] - TODO: an experimental architecture but actively developed,
variants in PureScript as well. A technology to investigate in the future, but
no ecosystem right now and not fully mature.

TODO: examples of Reflex, Miso, Concur

*** Build tools
The UI toolkit constrains the choice of possible build tools. In Haskell, there
are three mature options - Cabal (new-build) [TODO: ref], Stack, and Nix. There
is also a new fourth option aiming for the best of these four, Snack [TODO:
ref]. While it's not yet mature enough for serious use, it's a tool worth future
investigation.

Cabal - old, Cabal hell. Stack came, divided the Haskell community. Nix came out
of nowhere, converted a significant portion but isn't yet dominant, and now
cabal new-build is almost equivalent to stack. Free choice between cabal and
stack, nix is more capable in general but slower learning curve. TODO: more
about snack

GHCJS ecosystem not so well supported with Cabal (old or new one), Nix is
usually recommended at the frontend (one command setup, binary cache,
cross-platform), Reflex especially - uses the great Nix cross-compilation
capabilities for Android, iOS, desktop. Stack usable for plain GHCJS dev, but
old GHC (7.10?).

Slow compiler - common workaround is to use the REPL, but there are other
solutions like Snack which are promising although not widely used.

GHCJS output size and speed - GHCJS should be obsoleted by WebAssembly very
soon - it's already in alpha state, and I expect it will be ready for
production by the end of 2019.

Lack of editor integration - solved with LSP+HIE (usable in VSCode and other modern
editors), but Emacs is still the safest choice. Hlint (linter), Hindent
(formatter) built into HIE and Intero both, same goes for 'go-to-definition' and
'type-at-point' features common to modern IDEs. What's missing is debugger
integration - usually via GHCi only, but projects like haskell-dap (+ Phoityne
editor plugin) exist.

*** UI components
Preferred approach - implement UI and logic inside application code. FFI is
usable and quite simple for bigger components (see reflex-dom-ace).

Reflex and Concur - self-contained components and global state both (-> reusability)
Miso - single state atom only (see TEA)

*** Forms
No good options exist for any of the frameworks. While there are some attempts
at a forms library for Reflex, there is not a single feature-complete
library. Part of the reason - validation-only libraries exist in Haskell and
commonly used (see ~validation~, ~digestive-functors~). There are forms libraries at
the backend (see ~yesod-form~) with almost automatic form generation.

*** Routing
Miso has routing built-in. There are several attempts at a Reflex routing
library but not a single accepted solution. Concur with its small ecosystem
doesn't have even that.

*** Mobile/desktop apps
Reflex has this built-in via reflex-platform. Obelisk, building on top of
reflex-platform, includes bundling apps for App/Play Store. Cross-compilation via
Nix to Android/iOS, reflex-dom's bindings to WkWebView on desktop. I haven't
found any attempt to do this for Miso or Concur (Concur has beginnings of React
Native and SDL backends, but the development seems to have stalled).

*** Accessibility
I haven't found anything related to this topic, so I must assume no one has even
attempted to tackle it. Building accessible applications by yourself
isn't hard though.

*** Optimistic updates
I haven't found anything related to this topic. For FRP though, this should be
implemented at the data or network layers though, so this is something to work
towards when building the 'offline storage' library as per my assignment.

*** Web Plaftorm
The library JSaddle wraps the entirety of the Web Platform APIs using
WebIDL. Any UI library can use this library, though there are limited
event-based bindings, which means writing manual wrappers. (Reflex has some
machinery for a subset for it, Miso has subscriptions for some of them, Concur
uses ghcjs-vdom which has also some limited bindings.)

*** Prerender (Isomorphic rendering)
Reflex has explicit support, ~preRender~ allows even for two variants of an
element if it doesn't render well. Miso has explicit support as well. I haven't
found anything like this for Concur.

*** Support tools
Linter - Haskell standard is Hlint, support for custom rules, well-supported and
mature. Code formatter situation is more divided, Hindent follows gofmt with a
single code style for all code (but doesn't cover edge cases esp. for type-heavy
code, so not ideal). Brittany is an ambitious project using GHC's parser itself,
nicely designed formatting rules, but supports only a limited subset of the
language. Several other projects, some unmaintained, some brand new, but Hindent
seems to be standard at the moment.

The situation around code generators isn't ideal. Stack bundles several
templates, but is limited to Stack users. Cabal has a single template, nothing
else. Nix doesn't care about scaffolding. Several other tools, mostly
unmaintained - Summoner is a notable one, with a fixed project structure; Hi is
another one, supports arbitrary templates. There is no standard tool, usually
only 'git clone' a project template and start developing. Obelisk has a standard
structure, but it's a very limiting one (Snap as the only server library,
predetermined routing library obelisk-route, ...).

TODO: more code generation tooling - 'rails new
controller/scaffold/module/model/migration'

*** Quality Assurance
On this front, Haskell is very developed, at least theoretically. QuickCheck
originated in Haskell and quickly propagated to many other languages - followup
tools like SmallCheck and similar. That's generative, or property-based testing,
best in class.

Classical unit and integration testing has also many options - hspec, hedgehog,
tasty, doctest, ... Mocking via free monads or other MonadX
implementations. TODO

End-to-end testing - Selenium webdriver wrappers exist, and Selenium is the
standard for testing servers and clients. (Or alternately shelltestrunner for
testing CLI based applications.)

Benchmarking - best in class - criterion, no competition. Weigh - allocation
measurements as a benchmark.

*** Documentation
It is generally agreed that documentation is Haskell's weakest point. Despite
having a standardized high-quality APIdoc tool (haddock), documentation is often an
afterthought, with even commonly used packages having no documentation at all,
or written in such a way that a new user has no choice but to study its code to
understand the package.

*** Server-side tools

- Communication - typed APIs (HTTP - servant, WebSocket - some attempts, nothing
  production-ready)
- Entities - many options, some great, some less
- Migrations - weak point, I've found many half-baked implementations, but no
  standard solution (not only a Haskell problem, Liquibase is the only standard
  here, and that's SQL only)

** Implementation plan
I will use the nomenclature from the "Evolving Frameworks" paper [TODO: ref] to
describe my my goals. [TODO: describe the general outline of that paper]
Long-term, I am aiming to go from "Three Examples", a place to look for commonly
repeated patterns, through a "White-Box Framework", a general
structure/architecture of an application wrapped into a library, through a
"Component Library", when that library will be extended with commonly duplicated
functionality, all the way to "Pluggable Objects", where the framework provides
most of the commonly used functionality so that application logic is the only
thing missing from a finished prototype.

TODO: include the Evolving Frameworks image

Building an integrated platform is not my primary goal - it is hard for a new
and opinionated platform to succeed in the Haskell ecosystem (an not only
there). In this thesis, I expect to do the first step only - anything beyond
that is extra - create a few applications, fill in all the holes that aren't
covered by existing libraries, and extract a common application skeleton, a set
of libraries, and a set of guides or tutorials that make it is easy go from the
skeleton to a working prototype of a PWA. Anything beyond that - a "Component
Library" or "Pluggable Objects" - is only a bonus at this stage.

The goal of this work is to make it possible to create Progressive Web
Applications. To reiterate the description from the introduction, these are the
requirements:
- Pages are responsive on tablets & mobile devices
- All app URLs load while offline
- Metadata provided for Add to Home screen
- Page transitions don't feel like they block on the network
- Each page has a URL
- Pages use the History API
- Site uses cache-first networking
- Site appropriately informs the user when they're offline
- Push notifications (consists of several related requirements)

To get there, there are several features that aren't covered by any existing
Haskell library or tool. What follows is a list of tools that are required:
- A full-featured browser routing library. While there are some existing
  implementations, they are either incomplete or long abandoned.
- A wrapper around ServiceWorkers, or a template to simplify project creation.
- A push notifications library. This will need to be both a server-side library,
  for creating them, and a client-side consumer, to parse them.
- A way to prerender the application - either just the HTML 'shell' or all pages on the site.
- An offline storage library for the client.

There are many variations on the last point, 'offline storage', these are some of
them:
- plain storage datatype with LocalStorage, SessionStorage, and IndexedDB backends
- a storage including a transparent cache integrated with the network layer
- a storage with an invalidation or auto-refresh functionality, using an event
  stream from the server
- a storage with offline-capable synchronization capabilities

While my eventual goal is the last version, even just the first one would be
sufficient for the purposes of this work.

While these tools don't comprise a fully integrated 'platform' in the sense of
Angular or Symfony, those are quite uncommon in the Haskell ecosystem. More
common are collections of libraries that play well together, where one library
provides the fundamental datatype - the 'architecture' of the application, and
other libraries fill in the functionality. Of the proposed libraries, only the
routing library is an 'architectural' one in the sense that it will influence
the shape of the application and its fundamental datatypes.

These goals of course also include full documentation of their code, as well as
a test suite and benchmarks for performance-critical code.

* Components
TODO: Demonstrate the principles of components on 'src-snippets' code, where
I'll show the smallest possible code that implements that functionality

** Component A
*** Design
*** Implementation
*** Testing
*** Other options, possible improvements

* Applications
** Workflow and tools
TODO: describe the development flow of an app built using these tools

- starting out - three layer cake & esp. the inner one
- QA (tests, e2e, CI, ...), documentation
- development tool options
- deployment options

** TodoMVC

** RealWorld

* Conclusion
TODO: return to the comparison with JS, PHP, ... frameworks

TODO: describe possible follow-up work, what I'll be working on - define
  specific topics and make concrete examples

The final chapter includes an evaluation of the achieved results with a special
emphasis on the student's own contribution. A compulsory assessment of the
project's development will also be required, the student will present ideas
based on the experience with the project and will also show the connections to
the just completed projects. cite:Pravidla

* (bibliography, start of appendix)                           :ignoreheading:
#+BEGIN_EXPORT latex
\makeatletter
\def\@openbib@code{\addcontentsline{toc}{chapter}{Bibliography}}
\makeatother
\bibliographystyle{bib-styles/englishiso}

\begin{flushleft}
\bibliography{projekt}
\end{flushleft}
\iftwoside\cleardoublepage\fi

% Appendices
\appendix
\appendixpage
\iftwoside\cleardoublepage\fi

\startcontents[chapters]
% \setlength{\parskip}{0pt}
% \printcontents[chapters]{l}{0}{\setcounter{tocdepth}{2}}
% \setlength{\parskip}{0.5\bigskipamount}
\iftwoside\cleardoublepage\fi
#+END_EXPORT

* Contents of the attached data storage
TODO: fill in

* Poster
TODO: fill in
