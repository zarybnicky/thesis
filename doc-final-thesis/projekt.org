* (front matter)                                              :ignoreheading:
#+OPTIONS: texht:nil toc:nil author:nil
#+LATEX_CLASS: fitthesis
#+LATEX_CLASS_OPTIONS: [english,odsaz]
#+BIND: org-latex-title-command ""
# zadani = includes zadani.pdf
# print = B&W links and logo
# cprint = B&W links, color logo
# %\graphicspath{{obrazky-figures/}{./obrazky-figures/}}
#+LaTeX_HEADER: \input{metadata}
#+LaTeX_HEADER: \usepackage[figure,table]{totalcount}
#+BEGIN_LaTeX
\maketitle
\setlength{\parskip}{0pt}
{\hypersetup{hidelinks}\tableofcontents}
\iftotalfigures\listoffigures\fi
\iftotaltables\listoftables\fi
\iftwoside\cleardoublepage\fi
\setlength{\parskip}{0.5\bigskipamount}
#+END_LaTeX

* Introduction
- a concrete motivating example of a Haskell app that needs a web client, plus
  why to write a PWA
- general trends in Haskell and frontend development
- related work (Tweag, Obsidian, ...)

* Technologies
We'll first have a more detailed look at the above-mentioned technologies, [...]

** Haskell
The programming language Haskell is a rather old one, despite spreading into the
industry only recently, having been around since 1990 [TODO: reference]. It is a
language that started out as a basis for research into the design of functional
languages. It has served as such, and in fact it still is the target of active
research - some more prominent projects are "Dependent Haskell" [TODO: ref] and
"Linear Haskell" [TODO: ref].

Haskell is described as a "statically typed, purely functional programming
language with type inference and lazy evaluation" [TODO: ref]. It is a language
in which its expressive type system enables very precise control over TODO:
expressive types, dialog with the compiler, types encoding effects, citation for
"If it compiles, it works".

TODO: language to write reliable software in - it eliminates entire classes of
programming errors - usually the ones that remain are logic errors.

While Haskell is not a language commonly associated with frontend development,
it is one of the many languages with the ability to use JavaScript as the
compilation target, instead of plain assembly or LLVM. In fact, such languages
have now become quite common in frontend development [TODO: ref], as is
exemplified by the rapid rise of TypeScript, a superset of ECMAScript 6 [TODO:
ref], or Elm, a framework with its own language based on Haskell [TODO: ref].

Of the many reasons for selecting a language other than JavaScript for frontend
development, one of the more notable ones is the ability to share code between
the server and its client in the case they are written in the same
language. This is the basic idea of the framework Meteor [TODO: ref], and in
fact the ability to run 'isomorphic code' - the same code on the client and the
server both - is its main marketing point.

TODO: Haskell on the frontend is a rapidly growing area with many interested
companies. The main projects in this area are sponsored and developed by them -
some of the main contributors are: Obsidian (Reflex, Obelisk), Tweag (Asterius,
Inline-js), and QFPL (several UI components). [TODO: refs] While it's a quickly
growing area, it's still not an established one, and there are many libraries
and tools still missing, ones that developers used to other languages have
learned to expect and require.

#+BEGIN_SRC haskell :exports code
  type HackageAPI =
    "users" :> Get '[JSON] [User] :<|>
    "user" :> Capture "login" Login :> Get '[JSON] User :<|>
    "packages" :> Get '[JSON] [Package]

  getUsers :: Handler [User]
  getUser :: Login -> Handler User
  getPackages :: Handler [Package]

  server :: Server HackageApi
  server = getUsers :<|> getUser :<|> getPackages

  getUsers :<|> getUser :<|> getPackages =
    client @HackageApi "http://hackage.haskell.org"
#+END_SRC

** Nix
- /"Nix package manager, a "purely functional" package and configuration
  manager for computer systems"/ -- Wikipedia
- /"Describe your end result, then magic happens"/ \Smiley
- Tools build on top:
  - Nix = package manager
  - NixOS = operating system
  - NixOps = cloud deployment tool
- cross-compiling

- since 2004, Eelco Dolstra's Ph.D. thesis in 2006
- purely functional, lazy evaluation
- one program consists of a closure that includes all dependencies including libc
- atomic upgrades, rollbacks
- complete isolation of dependencies, no DLL hell
- NixOS = OS built on top of Nix
- NixOps = a cloud deployment tool
  - conceptually: Terraform/CloudFormation + Puppet/Ansible
  - a network specification -> magic -> running set of servers on AWS, VPSs,
    VirtualBox, ...

#+BEGIN_SRC nix :exports code
  {
    network.description = "Web server";

    webserver = { config, pkgs, ... }: {
      services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot =
        "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];

      deployment.targetEnv = "virtualbox";
    };
  }
#+END_SRC

** PWA
- concrete examples of existing apps
- general reasons for PWA development
- Web Platform APIs, Service Workers

* Research
In order to write a SPA/PWA, there are some tools and supporting libraries that
a developer can't live without. As this is not the focus of my thesis, I will
not explore the Web framework world systematically. We'll first walk through a
high-level overview of the common features of the Web frameworks of today, then
go through the most popular frameworks and see where they shine. Afterwards,
we'll have a look at the ecosystem of Haskell and try to find its strong and
weak points, and especially the places where the tools or libraries are entirely
missing.

** Common features of Web frameworks
-- A description of the things I'll be looking for, partially from
Wikipedia's [[https://en.wikipedia.org/wiki/Comparison_of_web_frameworks][Comparison of web frameworks]] and [[https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks][Comparison of JavaScript
frameworks]], partially from my own experience, and partially from the feature
lists of the frameworks that I'll be looking into.

*** Tooling
I'll start with the things you encounter first when setting up a project, its
tools. Developers have wildly differing levels of expectations from their tools. A
Python developer might expect just a text editor and an interpreter, whereas a
JVM developer might not be satisfied with anything less than a full-featured IDE.

*Code generators* or scaffolding tools start with creating a package manifest and
a ~src/~ directory, going on to generators that set up a few different types of
projects based on templates, all the way to tools that can add an entire website
module, perhaps even with database migrations.

*Build tools* range from a set of conventions on how to use your build tool that
might get formalized in your Makefile, through a CLI tool that takes care of
building, testing and perhaps even deploying your project, to the way of the IDE
where anything you can think of is just a few clicks away.

*Debugging tools* also come in many flavors and for many purposes. On the side of
the server, you have all the usual tools for the language, plus a few more - a
toolbar with an overview of everything that goes on in a page render or an AJAX
call, or the option to remotely connect to a running process and to debug
live. Client-side, we have the now irreplaceable DevTools with a built-in
debugger and profiler, but some frameworks go even further and provide a
framework-specific tools - React's component tree, or Elm's time-traveling
debugger.

*Quality assurance tools* have many sub-categories. From static code analysis
tools or linters, as they are commonly known; through tests - unit, integration,
end-to-end tests, or more exotic ones like marble tests or visual regression
tests; to profilers - runtime or allocation measurements, frontend performance
measurements, or more involved tools like performance evolution tracking.

*** Features
TODO: Reread and clean up

*Templating*, which at the frontend means a way to compose the HTML that makes up
an application, usually including some render logic and variable
interpolation. In some frameworks the whole program is a template (see React),
some have templates in separate files and pre-compile them during runtime (see
Angular). Templates sometimes contain CSS as well (see the new CSS-in-JS trend)

*Forms* are the basic element of interactive applications. There are a few layers
of abstraction at which a framework can decide to implement forms - starting at
raw DOM manipulation, going on to data containers with validation (but manual
rendering), all the way up to form builders, manual or automatic. Under 'forms'
I count a way to render a form, to validate user input, and collect the result.

*Routing* means manipulating the displayed URL using the History API and changing
the application state to reflect it, and also loading the correct state on
application start-up. This can also include animated transitions between pages.

*Internationalization* has many levels. At its most basic, it means simple string
translations, pluralization, and word order. Going further, it means also RTL
scripts, date/time formats, currency, or time zones.

Modern web frameworks also provide a way to use a web application's code and
compile it into a *native mobile application*. It's commonly implemented as a
wrapper application around web apps using Cordova, but technologies like React
Native go further and use native UI elements. Mobile applications can be faster
to use and faster to load, can access device-specific APIs not exposed via Web
Platform APIs.

Some frameworks also support creating a *desktop application* that reuses a web
application's code. The underlying technology here is Electron and not Cordova,
but the benefits are the same - greater speed and access to device-specific
functionality.

*** Accessibility (ARIA, ...)
- the key word now is ARIA = support for screen readers
- also, semantic elements, text contrast, customization
- also also, keyboard-accessibility (shortcuts, every clickable element
  accessible via keyboard = tabindex)
- accessibility testing (automatic as well, see aXe)

*** Optimistic updates
- one of the things I want to focus on
- broadly, expecting that every network request will be successful and updating
  the GUI accordingly
- rolling back app state in case of failure, with notifications

*** Web Platform
- location, camera, touch, vibration, ...

*** Pre-render
- one approach to shortening start-up times
- serving HTML with all the content already inside, no need for more requests to
  the backend for the initial page load
- JS takes over and uses what's already been loaded
- can be static or dynamic:
  - static = JAM stack, serving a bunch of files rendered at compile-time
  - dynamic = rendering the HTML at runtime

TODO: What about the backend feature write-ups I have?

** JavaScript ecosystem
*** Angular
TODO: what is it?
On a first look, Angular looks like a well thought-out frontend
framework. Written in Typescript with comprehensive documentation and great
tooling, it seems that the authors have learned from their mistakes with
AngularJS.

Some notable features:
- command line tool, ~ng~ - it streamlines setting up the entire project -
  scaffolding, preparing build and testing tools, starting a
  development server, ...
- runtime environments - from server-side rendering, PWAs with ServiceWorkers,
  to native and desktop applications, it seems that Angular tries to cover every
  possible use-case
- tooling other than the ~ng~ tool - browser extensions for runtime debugging,
  IDEs and others. I haven't thought of a tool I would miss, but I'm used to
  minimalism in tooling from the Haskell world...

Some negatives that developers complain about:
- Angular is intimidating for a new developer, it's too complex and there's a
  lot to learn
- Too much 'magic' - related to the previous point, there's a lot of abstraction
  and it's not easy to understand all the layers
- Code bloat - the amount of boilerplate and also the size of the resulting bundle
- Too opinionated - if you don't like 'the angular way', you're out of luck here
- scattered documentation - too many articles and tutorials out there for
  AngularJS that can't work with the new Angular

*** React
React is not a framework in itself. Rather, it's a library that focuses on a
single thing and does it in a unique enough way that there's sprung up an entire
ecosystem around it. In it, there are groups of libraries that build upon React,
each focusing on a single feature - UI components, state management, forms etc.

There's a large jungle of libraries, each one with a different scope and
focus. Choosing a library that fits your problem can sometimes take many
attempts. Add to it the fact that libraries, frameworks and tools come and go
quite quickly - the main cause of the so-called "JavaScript fatigue - and the
fact that in JavaScript, it's fashionable to write extremely small libraries,
and you have a recipe for a quite unpleasant development experience.

I'll try to go through some of the most popular 'frameworks' that build on
React, though each one is more of a pre-built toolkit of libraries and tools
and bits of glue in between, rather than cohesive frameworks. In general, the
React world is a lot more mix-and-match than developers used to enterprise
frameworks would expect.

Create-react-app, nwb, Razzle, and Neutrino all cover only the build
process. Next.js is the first one that I've found that goes a step beyond just
pre-configuring Webpack and other build tools - it provides other features that
are starting become standard - server-side runtime rendering, link prefetching,
and build-time prerendering. It's also the first tool I found that considers
that a website can consist of multiple applications, via its 'zones' feature.

TODO: developers' opinions

*** Gatsby
One rather unique framework I found - and this is a framework in a strong
sense, not like the React tools above - is Gatsby. It's unique in the sense that
while it's a frontend framework, it's not supposed to run in a browser. It's a
part of a growing movement centered around the 'JAM stack' - "JavaScript, APIs,
and Markup". That doesn't tell you much, but the main feature is that at
build-time, you fetch data from your APIs, and render the application to plain
HTML files, so that you don't need a server other than an S3 bucket or similar.

It's a framework targeted at a specific subset of website - not single-page
applications, but more blogs or e-shops, and a workflow exemplified by Netlify.
This means it doesn't need to concern itself with many features that would be
missing in a frontend framework intended for a browser, and those are delegated
to a different part of the stack.

TODO: opinions, structured pro/cons

*** Vue.js
TODO: Vue.js

*** Polymer
TODO: Polymer

** Haskell ecosystem
TODO: Compare Haskell compared to the above list

- its strong points
- passable but not ideal libraries
- what's missing

** Implementation plan
TODO: Somehow use the "Evolving frameworks" article

In this thesis, I'll focus mainly on the tools that are necessary specifically
for PWA development, not general quality-of-life libraries.

*Goal = app that fulfills the basic PWA criteria*:
- Pages are responsive on tablets & mobile devices
- All app URLs load while offline
- Metadata provided for Add to Home screen
- Page transitions don't feel like they block on the network
- Each page has a URL
- Pages use the History API
- Site uses cache-first networking
- Site appropriately informs the user when they're offline
- Push notifications (consists of several related requirements)

To achieve this, I need to create:
- A full-featured browser routing library. While there are some existing
  implementations, they are either incomplete or long abandoned.
- A wrapper around ServiceWorkers, or a template to simplify project creation.
- A push notifications library.
- A library or a script that will render HTML 'shells' of all pages on the site,
  for fast first load.
- CLI tool (requirement from assignment? "support tools")
- An offline storage library (some variant of it)

Not required by the checklist, but would improve the quality of my work:
- A template of an application, with predefined internal architecture, that uses
  all of the above libraries
- A utility library for querying and caching data from an API, be it HTTP, WebSocket,
  GraphQL, or others.

*Stretch goals*:
- a library to use in code shared between the server and client - a way to
  define the shape of the transport channel (and its API for non-Haskell
  applications)
- a server library, to allow user code to implement the specified protocol
- a client library with a storage component for entities and pending requests

TODO: talk about how these tools will fit into a 'platform', so that I check of
a box from the assignment

An application using these tools and libraries would consist of a server written
independently, and of a browser application. Implementing the communication
between them is left to the developer, as is implementing many common
conveniences usually provided by a framework.

*Stretch*: An application using these libraries would consist of a server and a client
sharing code that contains the definition of their communication channel. I do
not yet know how much these libraries would affect the shape/architecture of the
server, but the client library would form the core of the client - with the
libraries from the previous plan forming the shell.

These goals also include fully documenting the code written, as well as testing
and benchmarking it to remove the most obvious bottlenecks.

TODO: talk about Serverless, JAM stack, and alternative app structures:
- Client only. An application that doesn't need to communicate with a server,
  like a web presentation, or a blog, a set of pre-compiled HTML+JS files.
- Server only. Either just an API, or a plain HTML website with no JavaScript.
- Server and client, with the client rendered during run-time by the server.
- Server and client, with the client rendered during build-time and served
  separately (e.g. via an S3 bucket).
- Server and client, with the client re-rendered on demand, whenever the data that
  it shows changes. This is the shape of a 'JAM stack' application.
- Projects with multiple clients and/or servers (even more pressure on
  supporting tools)

* Components
TODO: Demonstrate the principles of components on 'src-snippets' code, where
I'll show the smallest possible code that implements that functionality

** Component A
*** Design
*** Implementation
*** Testing
*** Other options, possible improvements

* Applications
** Workflow and tools
TODO: describe the development flow of an app built using these tools

- starting out - three layer cake & esp. the inner one
- QA (tests, e2e, CI, ...), documentation
- development tool options
- deployment options

** TodoMVC

** RealWorld

* Conclusion
TODO: return to the comparison with JS, PHP, ... frameworks

TODO: describe possible follow-up work, what I'll be working on - define
  specific topics and make concrete examples

The final chapter includes an evaluation of the achieved results with a special
emphasis on the student's own contribution. A compulsory assessment of the
project's development will also be required, the student will present ideas
based on the experience with the project and will also show the connections to
the just completed projects.

* (bibliography, start of appendix)                           :ignoreheading:
#+BEGIN_LaTeX
\makeatletter
\def\@openbib@code{\addcontentsline{toc}{chapter}{Bibliography}}
\makeatother
\bibliographystyle{bib-styles/englishiso}

\begin{flushleft}
\bibliography{projekt}
\end{flushleft}
\iftwoside\cleardoublepage\fi

% Appendices
\appendix
\appendixpage
\iftwoside\cleardoublepage\fi

\startcontents[chapters]
% \setlength{\parskip}{0pt}
% \printcontents[chapters]{l}{0}{\setcounter{tocdepth}{2}}
% \setlength{\parskip}{0.5\bigskipamount}
\iftwoside\cleardoublepage\fi
#+END_LaTeX

* Contents of the attached data storage
TODO: fill in

* Poster
TODO: fill in
