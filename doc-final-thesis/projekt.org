* (front matter)                                              :ignoreheading:
#+OPTIONS: texht:nil toc:nil author:nil
#+LATEX_CLASS: fitthesis
#+LATEX_CLASS_OPTIONS: [english,odsaz]
#+BIND: org-latex-title-command ""
# zadani = includes zadani.pdf
# print = B&W links and logo
# cprint = B&W links, color logo
# %\graphicspath{{obrazky-figures/}{./obrazky-figures/}}
#+LaTeX_HEADER: \input{metadata}
#+LATEX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usepackage[figure,table]{totalcount}
#+BEGIN_EXPORT latex
\maketitle
\setlength{\parskip}{0pt}
{\hypersetup{hidelinks}\tableofcontents}
\iftotalfigures\listoffigures\fi
\iftotaltables\listoftables\fi
\iftwoside\cleardoublepage\fi
\setlength{\parskip}{0.5\bigskipamount}
#+END_EXPORT

* Introduction
Let's imagine we want to create a new e-shop, with all the conveniences that
customers are nowadays used to - [TODO: ...], a notification when the order is
ready, and ideally an offline-available overview of the order for when the user
is picking it up. What would be the easiest way to implement such a service? If
we want to show something offline, we need a mobile application, the same for
notifications. But [TODO: research about mobile engagement] and downloading a
mobile application means another dozen megabytes.

That's what the new trend of Progressive Web Applications (PWAs) is trying to
solve. Fast - no need to wait for page reloads, Reliable - service workers help
overcome problems with unreliable internet - both for page load (by caching the
app itself, and in-app caching of app-specific data) and for background sync of
user-modified data.

My language of choice is Haskell though, for both frontend and backend
development, and while writing Haskell applications for the browser is possible,
creating a Progressive Web Application requires more than just the ability to
manipulate the DOM. That is what this work is about - filling in the gaps and
creating all the prerequisites for writing Progressive Web Applications in
Haskell. We will start by identifying what is exactly is lacking in the Haskell
ecosystem and design and implement those missing pieces. Afterwards, we'll walk
through the process of creating a PWA from prototype to production and see what
else could be made easier and more straightforward as a follow-up to this work.

** Related work
While using Haskell in the browser is not a common choice, it is still a quickly
growing niche. it is a relatively recent one as GHCJS, the Haskell-to-JavaScript
compiler, has been in development since 2010 [TODO: gh repo link] but it had a
production-ready version only in 2013 [luite's blog]. It is not the target of
academic work, but there are several commercially sponsored projects. To name a
few, Reflex and Obelisk from Obsidian Systems [TODO: link], Asterius from Tweag,
and many learning materials from QFPL [TODO: their github].

While it's a quickly growing area, it's still not an established one, and there
are many libraries and tools still missing, ones that developers used to other
languages have learned to expect and require.

* Technologies
We'll first have a more detailed look at the above-mentioned technologies, at
what the term Progressive Web Application means and why would one want to use
Haskell when creating browser applications.

** Progressive Web Application
"Progressive Web Application" is a term that covers several relatively new
technologies. It is the continuation of the general trend of expanding the
capabilities of browser applications and closing the gap between them and native
mobile applications. While many of these technologies apply also on desktop, the
main target audience is mobile - [TODO: some statistics].

The technologies are:
- Web App Manifest - a specification for the centralized location of application
  metadata - its name, icons, display mode, ...
- Service Workers - "a scriptable network proxy" [TODO: as per Wiki]. The
  technology that takes care of offline-availability, push notifications, and
  background synchronization.
- IndexedDB - a storage location that is accessible from the browser as well as
  the service worker, it allows background sync to work with the application
  state directly
- Web Platform APIs - a set of APIs that expose capabilities of the underlying
  system [TODO: https://whatwebcando.today/] - examples include geolocation or
  audio/video capture

What is a Progressive Web Applications exactly is defined by a checklist created
by Google, the https://developers.google.com/web/progressive-web-apps/checklist
[TODO: ref]. It describes two levels of PWAs, a 'Baseline PWA' and an 'Exemplary
PWA'. The main defining characteristics of a Baseline PWA are: served over
HTTPS, responsive design, all URLs available even while offline, and
non-blocking page transitions. While there are more requirements for an
Exemplary PWA, these are the most important ones.

Some more notable PWAs are: Instagram, Twitter [TODO: refs, see wiki], Uber,
Flipkart, or Tinder.

** Haskell
The programming language Haskell is a rather old one, despite spreading into the
industry only recently, having been around since 1990 [TODO: reference]. It is a
language that started out as a basis for research into the design of functional
languages. It has served as such, and in fact it still is the target of active
research - some more prominent projects are "Dependent Haskell" [TODO: ref] and
"Linear Haskell" [TODO: ref].

Haskell is described as a "statically typed, purely functional programming
language with type inference and lazy evaluation" [TODO: ref]. It is a language
in which its expressive type system enables very precise control over TODO:
expressive types, dialog with the compiler, types encoding effects, citation for
"If it compiles, it works".

Why Haskell? Strongly typed language, helps ensure correctness and prevent
undefined behaviors - but less verbose and more expressive than Java and other
languages a developer would imagine as 'strongly typed'. Haskell is one of the
many languages that can be used in the browser - not directly, but by compiling
down to JavaScript. WebAssembly is a technology that encourages this way
of working, enabling any language to run in the browser via LLVM. (Compiling
Haskell to WebAssembly is almost doable [TODO: ref WebGHC, Asterius].)

Compile-to-JavaScript languages aren't as rare as it may seem. While languages
that aren't based on JavaScript itself aren't exactly common, web developers
have been using JavaScript compilers for a long time - CoffeeScript is rather
popular language announced in 2010 [TODO: ref], and developers wanting to use
new ECMAScript 6 or 7 features (now supported in most browsers) also had no
choice but to use compilers [TODO: ref Babel history].

It is a language that enables its users to write reliable software - it
eliminates entire classes of programming errors [TODO: ref, enumerate]. The
errors that remain even after the program successfully compiles are usually
logic or conceptual errors.

While Haskell is not a language commonly associated with frontend development,
it is one of the many languages with the ability to use JavaScript as the
compilation target, instead of plain assembly or LLVM. In fact, such languages
have now become quite common in frontend development [TODO: ref], as is
exemplified by the rapid rise of TypeScript, a superset of ECMAScript 6 [TODO:
ref], or Elm, a framework with its own language based on Haskell [TODO: ref].

Of the many reasons for selecting a language other than JavaScript for frontend
development, one of the more notable ones is the ability to share code between
the server and its client in the case they are written in the same
language. This is the basic idea of the framework Meteor [TODO: ref], and in
fact the ability to run 'isomorphic code' - the same code on the client and the
server both - is its main marketing point.

#+BEGIN_SRC haskell :exports code
  type HackageAPI =
    "users" :> Get '[JSON] [User] :<|>
    "user" :> Capture "login" Login :> Get '[JSON] User :<|>
    "packages" :> Get '[JSON] [Package]

  getUsers :: Handler [User]
  getUser :: Login -> Handler User
  getPackages :: Handler [Package]

  server :: Server HackageApi
  server = getUsers :<|> getUser :<|> getPackages

  getUsers :<|> getUser :<|> getPackages =
    client @HackageApi "http://hackage.haskell.org"
#+END_SRC

** Nix
One technology that wasn't yet mentioned but that will support our entire build
process - from compiling to deploying - is Nix. Nix is a package manager with
focus on reproducibility and isolation. It is described as a purely functional
package manager, where every package is build by a function that doesn't have
side-effects and is immutable after being built, where Nix ensures that the
exact version of dependencies is used even during runtime - up to ~libc~ [TODO:
ref homepage]

Nix is a declarative build tool, similar in purpose to Make and in philosophy to
Haskell. There are other tools built on top of Nix though, the most interesting
being NixOS, a declarative operating system, and NixOps, a cloud deployment tool
[TODO: refs]. Nix shines at cross-compilation, which is the main I'll use it in
this thesis - compiling to JavaScript or Android/iOS is trivial after the
initial setup.

Nix is another rather old technology actively developed since 2004 after Eelco
Dolstra developed this idea in his academic work [TODO: refs]. One package
consists of a closure of all of its runtime dependencies, so even packages using
different versions of dynamically linked libraries or even libc can coexist on
the same machine. Adding atomic deployments and rollbacks is then quite easy, as
a user environment only consists of symbolic links to the read-only Nix store -
that is very useful for NixOS or NixOps.

#+BEGIN_SRC nix :exports code
{ stdenv, fetchurl, perl }:

stdenv.mkDerivation {
  name = "hello-2.1.1";
  builder = ./builder.sh;
  src = fetchurl {
    url = ftp://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz;
    sha256 = "1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465";
  };
  inherit perl;
}
#+END_SRC

#+BEGIN_SRC nix :exports code
  {
    network.description = "Web server";

    webserver = { config, pkgs, ... }: {
      services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot =
        "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];

      deployment.targetEnv = "virtualbox";
    };
  }
#+END_SRC

* Research
As this work doesn't live in a vacuum, we also need to consider commonly used
Web frameworks and platforms and decide what features to we need to implement in
this work. We will first walk through the features that frameworks today
implement, describe them and define the relevant terms. Afterwards, we will have
a look at the ecosystems of JavaScript -- today almost the only option for
writing frontend applications -- and Haskell, my language of choice, and try to
find the places where Haskell is lagging behind and especially the features that
we will need to fill in in this work.

** Features of Web frameworks
The basis of a web framework is the *UI toolkit*, which defines the structure,
architecture and paradigm of the rest of the application. I am intentionally
using the now-uncommon term 'toolkit', as the UI frameworks we will see vary in
their scope - e.g. React is just a library with a very small API, whereas
Angular provides a quite opinionated platform, rather than a
framework. Individual frameworks are very disparate, with large differences in
the size of their community, maturity, developer friendliness and the breadth of
features or available libraries.

Frameworks usually have one defining feature they are built around (virtual DOM
for React or event streams for Angular), but there are several features that a
framework needs to take care of - *templating* is one of them. It is a way of
composing the HTML that makes up an application which also usually includes some
'view logic' and variable interpolation. In some frameworks the whole program is
a template (purely-functional React), some have templates in separate files and
pre-compile them during the build process or even in the browser
(Angular). Templates may also contain CSS as well - see the new CSS-in-JS trend.

The second defining feature of frameworks is *state management*. This rather vague
concept may include receiving input from the user, displaying the state back to
the user, communicating with APIs and caching the responses, etc. While state
management is simple at a small scale, there are many problems that appear only
in larger applications with several developers. Some approaches include: a
'single source of the truth' and immutable data (Redux), local state in
hierarchical components (Angular), or unidirectional data flow with several
entity stores (Flux).

Another must-have feature of a framework is *routing*, which means manipulating
the displayed URL using the History API, and changing it to reflect the
application state and vice-versa. It also includes switching the application to
the correct state on start-up. While the router is usually a rather small
component, it is fundamental to the application in the same way the previous two
items are.

A component where frameworks differ a lot is a *forms* system. There are a few
layers of abstraction at which a framework can decide to implement forms,
starting at raw DOM manipulation, going on to data containers with validation
but manual rendering, all the way up to form builders using domain-specific
languages. The topic of "forms" includes rendering a form and its data,
accepting data from the user and validating it, and sometimes even submitting it
to an API.

There are other features that a framework can provide - authentication,
standardized UI components, and others - but frameworks usually leave these to
third party libraries. There is one more topic I would like to mention that is
usually too broad to cover in the core of a framework, but very important to
consider when developing an application. *Accessibility* is an area concerned with
removing barriers that would prevent any user from using a website. It has many
parts to it - while the main focus is making websites accessible to
screen-readers, it also includes supporting other modes of interaction, like
keyboard-only interaction. Shortening *load times* on slow connections also makes
a website accessible in parts of the world with slower Internet connections, and
supporting *internationalization* removes language and cultural barriers.

Accessibility is something that requires framework support on several
levels. Making a site accessible requires considerations during both design
(e.g. high color contrast) and implementation (semantic elements and ARIA
attributes), and that is usually left up to application code and accessibility
checklists, with the exception of some specialized components like keyboard
focus managers. There are however tools like aXe-core that check how accessible
a finished framework is, and these can be integrated into the build process.

Supporting *internationalization* in a framework is easier - not to implement, but
simple to package as a library. At the most basic level, it means simple string
translations, perhaps with pluralization and word order. Going further, it may
also mean supporting RTL scripts, different date/time formats, currency, or time
zones.

As for *load times*, there are many techniques frameworks use to speed up the
initial load of an application. We can talk about the first load, which can be
sped up by compressing assets (CSS, fonts, fonts or scripts) and removing
redundant ones, or by preparing some HTML that can be displayed to the user
while the rest of the application is loading to increase the perceived
speed. After the first load, the browser has some of the application's assets
cached, so loading will be faster. One of the requirements of a PWA is using the
Service Worker for instantaneous loading after the first load.

There are two patterns of preparing the HTML that is shown while the rest of the
application is loading - so called *prerendering*. One is called "app shell",
which is a simple static HTML file that contains the basic structure of the
application's layout. The other is "server-side rendering", and it is a somewhat
more advanced technique where the entire contents of the requested URI is
rendered on the server including the data of the first page, and the browser
part of the application takes over only afterwards, but doesn't need to fetch
anymore data. There is another variant of "server-side rendering" called the
"JAM stack" pattern, where after application state changes, the HTML of the
entire application, of all application URLs is rendered all at once and saved so
that the server doesn't need to render the HTML for every request. These
techniques are usually part of a framework's *supporting tools*, about which we
will talk now.

Developers from different ecosystems have wildly varying expectations on their
tools. A Python developer might expect just a text editor and an interpreter,
whereas a JVM or .NET developer might not be satisfied with anything less than a
full-featured IDE. We will start with the essentials, with *build
tools*. Nowadays, even the simplest JavaScript application usually uses a build
step that packages all its source code and styles into a single bundle for
faster loading. A framework's tool-chain may range from a set of conventions on
how to use the compiler that might get formalized in a Makefile, through a CLI
tool that takes care of building, testing and perhaps even deploying the
application, to the way of the IDE, where any build variant is just a few clicks
away.

*Debugging tools* are the next area. After building an application, trying it out
and finding an error, these tools help to find the error. There are general
language-specific tools - a stepping debugger is a typical example - and there
are also framework-specific tools, like an explorer of the component hierarchy
(React) or a time-traveling debugger (Redux). In the web world, all modern
browsers provide the basic debugging tools inside the 'DevTools' - a stepping
debugger and a profiler. some frameworks provide an extension to DevTools that
interacts with the application in the current window, and some integrate their
debugging tools into the application itself.

When building a large application with several developers, it is necessary to
ensure good practices from all of them - a good practice
to require a common style for the entire code base. *Quality assurance tools* have
many sub-categories. From static code analysis tools or linters, as they are
commonly known; through tests - unit, integration, end-to-end tests, or more
exotic ones like marble tests or visual regression tests; to profilers - runtime
or allocation measurements, frontend performance measurements, or more involved
tools like performance evolution tracking.

TODO: editor support

TODO: general 'platforms' intro: Modern web frameworks also provide a way to use
a web application's code and compile it into a *native mobile application*. It's
commonly implemented as a wrapper application around web apps using Cordova, but
technologies like React Native go further and use native UI elements. Mobile
applications can be faster to use and faster to load, can access device-specific
APIs not exposed via Web Platform APIs.

Some frameworks also support creating a *desktop application* that reuses a web
application's code. The underlying technology here is Electron and not Cordova,
but the benefits are the same - greater speed and access to device-specific
functionality.

TODO: "one last tool, a bonus, if you would" *Code generators* or scaffolding tools start with creating a package manifest and
a ~src/~ directory, going on to generators that set up a few different types of
projects based on templates, all the way to tools that can add an entire website
module, perhaps even with database migrations.

** JavaScript ecosystem
The most popular JavaScript *UI toolkits* currently are Angular and React. Vue.js
is another one, relatively new but quickly growing. Of these, Angular is the
framework closest to traditional frameworks where to create an application, the
framework is all you need. React and Vue are both rather small libraries but
have many supporting tools that together also create a platform, although they
are less cohesive than Angular's platform.

TODO: finish: There are fundamental architectural differences between them. Angular 
On a first look, Angular looks like a well thought-out frontend
framework. Written in Typescript with comprehensive documentation and great
tooling, it seems that the authors have learned from their mistakes with
AngularJS.

React is not a framework in itself. Rather, it's a library that focuses on a
single thing and does it in a unique enough way that there's sprung up an entire
ecosystem around it. In it, there are groups of libraries that build upon React,
each focusing on a single feature - UI components, state management, forms etc.

TODO: Vue.js
TODO: Polymer

*Developer experience* - complaints about Angular, React, the good things as well.

There's a large jungle of libraries, each one with a different scope and
focus. Choosing a library that fits your problem can sometimes take many
attempts. Add to it the fact that libraries, frameworks and tools come and go
quite quickly - the main cause of the so-called "JavaScript fatigue - and the
fact that in JavaScript, it's fashionable to write extremely small libraries,
and you have a recipe for a quite unpleasant development experience.

Some negatives that developers complain about: Angular is intimidating for a new
developer, it's too complex and there's a lot to learn. Too much 'magic' -
related to the previous point, there's a lot of abstraction and it's not easy to
understand all the layers. Code bloat - the amount of boilerplate and also the
size of the resulting bundle. Too opinionated - if you don't like 'the angular
way', you're out of luck here. Scattered documentation - too many articles and
tutorials out there for AngularJS that can't work with the new Angular


TODO: mention the large *UI component* libraries - material, bootstrap, ...
TODO: fill in, mention library names and relative quality and architecture
differences

*Templating* - Angular and Vue's custom HTML, React's JSX or plain JS

*Forms* - Angular's several options, React's breadth of tools @ different
abstraction levels

*Routing* is built into Angular, several libraries and approaches for React

*Accessibility* is explicitly supported in React and Angular, a11y testing tools

*Prerendering* supported by a server (react-server) or with static
prerender. TODO: angular, vue, polymer?

*Build tools* - Webpack, Babel, ...

TODO: react's tools
Create-react-app, nwb, Razzle, and Neutrino all cover only the build
process. Next.js is the first one that I've found that goes a step beyond just
pre-configuring Webpack and other build tools - it provides other features that
are starting become standard - server-side runtime rendering, link prefetching,
and build-time prerendering. It's also the first tool I found that considers
that a website can consist of multiple applications, via its 'zones' feature.

TODO: more fluent *Mobile/desktop apps* - Angular claims built-in support for native and desktop
applications. React does not have explicit support but Cordova and Electron (and
others) are all built for JavaScript.

TODO: more fluent *Support tools* - Angular has its ~ng~ tool which it streamlines setting up the
entire project (scaffolding, preparing build and testing tools, starting a
development server) and also browser extensions for runtime debugging,
IDEs and others. I haven't thought of a tool I would miss, but I'm used to
minimalism in tooling from the Haskell world... React has a browser extension
for runtime debugging but other tools depend on the distribution and/or time and
effort to set them up.

** Haskell ecosystem
TODO: remove intro: At the frontend, it is the *UI toolkit* that defines what the entire application
will look like, its architecture as well as the tools it can use. There is
significant focus on the semantics of libraries in the Haskell community, with
well-defined and law-abiding foundation types, so UI libraries have mostly used
Functional Reactive Programming (FRP) or its derivatives like 'the Elm
architecture' [TODO: ref] as their basis.

There are five production-ready browser UI toolkits that I have found. Out of
these five, React-flux and Transient are unmaintained. Reflex, Miso, and Concur
are actively developed and ready for production use. Each one is a conceptually
different approach to the problem of browser user interfaces, but they differ in
their maturity and the size of their community as well.

*Reflex* [TODO: ref] and Reflex-DOM [TODO: ref], its DOM bindings, seem like the
most actively maintained ones. Reflex is also sponsored by Obsidian Systems
[TODO: ref] and the most popular one in the Haskell community, so its future
seems promising. Reflex follows the traditional FRP with events and behaviors,
adding 'dynamics' to the mix, and building a rich combinator library on top of them.

*Miso* [TODO: ref] - TODO: Elm architecture re-implementation in Haskell

*Concur* [TODO: ref] - TODO: an experimental architecture but actively developed,
variants in PureScript as well. A technology to investigate in the future, but
no ecosystem right now and not fully mature.

TODO: examples of Reflex, Miso, Concur

TODO: English! In all of these frameworks, the preferred approach for *UI components* is to
re-implement UI and logic inside application code. FFI is usable and quite
simple for bigger components (see reflex-dom-ace). No real separation of
concerns, at least markup and data flow are tightly interlinked (style separate,
no CSS-in-JS equivalent yet). Better type-safety and clearer interdependencies,
but requires a high baseline of Haskell experience.

TODO: English! Reflex and Concur - self-contained components and global state both (->
reusability) Miso - single state atom only (see TEA)

TODO: less subjective! I haven't found any good options for *forms* in any of the frameworks. While there
are some attempts at a forms library for Reflex, there is not a single
feature-complete library. Part of the reason - validation-only libraries exist
in Haskell and commonly used (see ~validation~, ~digestive-functors~). There are
forms libraries at the backend (see ~yesod-form~) with almost automatic form
generation.

TODO: English! Miso has *routing* built-in. There are several attempts at a Reflex routing
library but not a single accepted solution. Concur with its small ecosystem
doesn't have even that.

TODO: mention no support, reusing JS tools! I haven't found anything related to
*accessibility*, so I must assume no one has even attempted to tackle it in a
systematic way. Building accessible applications by yourself isn't hard though.

*Loading speed* - big JS output, so prerendering (Isomorphic rendering) and HTTP/2
Push.  Reflex has explicit support for prerendering, where an element can have
two variants if it doesn't render well. Miso has explicit support as well. I
haven't found anything like this for Concur.

TODO: English! The UI toolkit constrains the choice of possible *build tools*. In Haskell, there
are three mature options - Cabal (new-build) [TODO: ref], Stack, and Nix. There
is also a new fourth option aiming for the best of these four, Snack [TODO:
ref]. While it's not yet mature enough for serious use, it's a tool worth future
investigation.

TODO: English! Cabal - old, Cabal hell. Stack came, divided the Haskell community. Nix came out
of nowhere, converted a significant portion but isn't yet dominant, and now
cabal new-build is almost equivalent to stack. Free choice between cabal and
stack, nix is more capable in general but slower learning curve. TODO: more
about snack

TODO: English! GHCJS ecosystem not so well supported with Cabal (old or new one), Nix is
usually recommended at the frontend (one command setup, binary cache,
cross-platform), Reflex especially - uses the great Nix cross-compilation
capabilities for Android, iOS, desktop. Stack usable for plain GHCJS dev, but
old GHC (7.10?).

TODO: English! Slow compiler - common workaround is to use the REPL, but there are other
solutions like Snack which are promising although not widely used.

TODO: English! GHCJS output size and speed - GHCJS should be obsoleted by WebAssembly very
soon - it's already in alpha state, and I expect it will be ready for
production by the end of 2019.

TODO: English! Lack of *editor integration* - solved with LSP+HIE (usable in
VSCode and other modern editors), but Emacs is still the safest choice. Hlint
(linter), Hindent (formatter) built into HIE and Intero both, same goes for
'go-to-definition' and 'type-at-point' features common to modern IDEs. What's
missing is debugger integration - usually via GHCi only, but projects like
haskell-dap (+ Phoityne editor plugin) exist.

TODO: English! *Mobile/desktop apps* - reflex has this built-in via reflex-platform. Obelisk,
building on top of reflex-platform, includes bundling apps for App/Play
Store. Cross-compilation via Nix to Android/iOS, reflex-dom's bindings to
WkWebView on desktop. I haven't found any attempt to do this for Miso or Concur
(Concur has beginnings of React Native and SDL backends, but the development
seems to have stalled).

TODO: English! *Support tools*, starting with a linter - Haskell standard is Hlint, support for
custom rules, well-supported and mature. Code formatter situation is more
divided, Hindent follows gofmt with a single code style for all code (but
doesn't cover edge cases esp. for type-heavy code, so not ideal). Brittany is an
ambitious project using GHC's parser itself, nicely designed formatting rules,
but supports only a limited subset of the language. Several other projects, some
unmaintained, some brand new, but Hindent seems to be standard at the moment.

TODO: English! The situation around *code generators* isn't ideal. Stack bundles
several templates, but is limited to Stack users. Cabal has a single template,
nothing else. Nix doesn't care about scaffolding. Several other tools, mostly
unmaintained - Summoner is a notable one, with a fixed project structure; Hi is
another one, supports arbitrary templates. There is no standard tool, usually
only 'git clone' a project template and start developing. Obelisk has a standard
structure, but it's a very limiting one (Snap as the only server library,
predetermined routing library obelisk-route, ...).

TODO: more code generation tooling - 'rails new
controller/scaffold/module/model/migration'

*Quality Assurance* - on this front, Haskell is very developed, at least theoretically. QuickCheck
originated in Haskell and quickly propagated to many other languages - followup
tools like SmallCheck and similar. That's generative, or property-based testing,
best in class.

Classical unit and integration testing has also many options - hspec, hedgehog,
tasty, doctest, ... Mocking via free monads or other MonadX
implementations. TODO

End-to-end testing - Selenium webdriver wrappers exist, and Selenium is the
standard for testing servers and clients. (Or alternately shelltestrunner for
testing CLI based applications.)

Benchmarking - best in class - criterion, no competition. Weigh - allocation
measurements as a benchmark.

*Documentation* - it is generally agreed that documentation is Haskell's weakest
point. Despite having a standardized high-quality APIdoc tool (haddock),
documentation is often an afterthought, with even commonly used packages having
no documentation at all, or written in such a way that a new user has no choice
but to study its code to understand the package.

** Implementation plan
I will use the nomenclature from the "Evolving Frameworks" paper [TODO: ref] to
describe my my goals. [TODO: describe the general outline of that paper]
Long-term, I am aiming to go from "Three Examples", a place to look for commonly
repeated patterns, through a "White-Box Framework", a general
structure/architecture of an application wrapped into a library, through a
"Component Library", when that library will be extended with commonly duplicated
functionality, all the way to "Pluggable Objects", where the framework provides
most of the commonly used functionality so that application logic is the only
thing missing from a finished prototype.

TODO: include the Evolving Frameworks image

Building an integrated platform is not my primary goal - it is hard for a new
and opinionated platform to succeed in the Haskell ecosystem (an not only
there). In this thesis, I expect to do the first step only - anything beyond
that is extra - create a few applications, fill in all the holes that aren't
covered by existing libraries, and extract a common application skeleton, a set
of libraries, and a set of guides or tutorials that make it is easy go from the
skeleton to a working prototype of a PWA. Anything beyond that - a "Component
Library" or "Pluggable Objects" - is only a bonus at this stage.

The goal of this work is to make it possible to create Progressive Web
Applications. To reiterate the description from the introduction, these are the
requirements:
- Pages are responsive on tablets & mobile devices
- All app URLs load while offline
- Metadata provided for Add to Home screen
- Page transitions don't feel like they block on the network
- Each page has a URL
- Pages use the History API
- Site uses cache-first networking
- Site appropriately informs the user when they're offline
- Push notifications (consists of several related requirements)

To get there, there are several features that aren't covered by any existing
Haskell library or tool. What follows is a list of tools that are required:
- A full-featured browser routing library. While there are some existing
  implementations, they are either incomplete or long abandoned.
- A wrapper around ServiceWorkers, or a template to simplify project creation.
- A push notifications library. This will need to be both a server-side library,
  for creating them, and a client-side consumer, to parse them.
- A way to prerender the application - either just the HTML 'shell' or all pages on the site.
- An offline storage library for the client.

There are many variations on the last point ('offline storage'), these are some of
them:
- plain storage datatype with LocalStorage, SessionStorage, and IndexedDB backends
- a storage including a transparent cache integrated with the network layer
- a storage with an invalidation or auto-refresh functionality, using an event
  stream from the server
- a storage with offline-capable synchronization capabilities

While my eventual goal is the last version, even just the first one would be
sufficient for the purposes of this work.

While these tools don't comprise a fully integrated 'platform' in the sense of
Angular or Symfony, those are quite uncommon in the Haskell ecosystem. More
common are collections of libraries that play well together, where one library
provides the fundamental datatype - the 'architecture' of the application, and
other libraries fill in the functionality. Of the proposed libraries, only the
routing library is an 'architectural' one in the sense that it will influence
the shape of the application and its fundamental datatypes.

These goals of course also include full documentation of their code, as well as
a test suite and benchmarks for performance-critical code.

* Components
TODO: Demonstrate the principles of components on 'src-snippets' code, where
I'll show the smallest possible code that implements that functionality

** Component A
*** Design
*** Implementation
*** Testing
*** Other options, possible improvements

* Applications
** Workflow and tools
TODO: describe the development flow of an app built using these tools

- starting out - three layer cake & esp. the inner one
- QA (tests, e2e, CI, ...), documentation
- development tool options
- deployment options

** TodoMVC
There is an abundance of web frameworks, and there are several projects that aim
to give developers a side-by-side comparison of them. Out of these, the original
and most well-known one is TodoMVC, which is aimed at 'MV* frontend
frameworks'. There are currently 64 implementations of their specification -
some of them are variants of the same framework though. There are a few others -
HNPWA is aimed at Progressive Web Applications and it is a tad smaller, with 42
implementations. The last comparison project that I've selected is
RealWorld. This one has both a frontend and a backend part and there is also a
small number of full-stack frameworks. It offers a quite thorough comparison,
with 18 frontends, 34 backends, and 3 full-stack implementations.

We will start with TodoMVC as it is the simplest of the three. TodoMVC is, as
the name hints, a web application for managing a to-do list. It is not a complex
project but it should exercise the basics of a framework - DOM manipulation,
forms and validation, state management (in-memory and in LocalStorage), and
routing.

http://todomvc.com/

** HNPWA
HNPWA is a client for Hacker News, a technological news site. Unlike TodoMVC,
HNPWA does not provide a rigid specification and consists only of a rough
guideline of what to implement. The task is to create a Progressive Web
Application that displays information from a given API. The application must be
well optimized (to achieve score 90 in the Lighthouse tool) with optional
server-side rendering.

https://hnpwa.com/

** RealWorld
RealWorld is the most complex of the comparison projects. It is a clone of
Medium, an online publishing platform, so it requires everything a "real world"
application would. The task is split into a backend, defined by an API
specification, and a frontend, defined by an HTML structure.

There is a number of features the application needs to support, namely: JWT
(JSON Web Token) authentication with registration and user management, the
ability to post articles and comments, and to follow users and favorite articles.

https://github.com/gothinkster/realworld

* Conclusion
TODO: return to the comparison with JS, PHP, ... frameworks

TODO: describe possible follow-up work, what I'll be working on - define
  specific topics and make concrete examples

The final chapter includes an evaluation of the achieved results with a special
emphasis on the student's own contribution. A compulsory assessment of the
project's development will also be required, the student will present ideas
based on the experience with the project and will also show the connections to
the just completed projects. cite:Pravidla

* (bibliography, start of appendix)                           :ignoreheading:
#+BEGIN_EXPORT latex
\makeatletter
\def\@openbib@code{\addcontentsline{toc}{chapter}{Bibliography}}
\makeatother
\bibliographystyle{bib-styles/englishiso}

\begin{flushleft}
\bibliography{projekt}
\end{flushleft}
\iftwoside\cleardoublepage\fi

% Appendices
\appendix
\appendixpage
\iftwoside\cleardoublepage\fi

\startcontents[chapters]
% \setlength{\parskip}{0pt}
% \printcontents[chapters]{l}{0}{\setcounter{tocdepth}{2}}
% \setlength{\parskip}{0.5\bigskipamount}
\iftwoside\cleardoublepage\fi
#+END_EXPORT

* Contents of the attached data storage
TODO: fill in

* Poster
TODO: fill in
